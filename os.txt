Process Scheduling

######## FCFS #########

#include <stdio.h>

typedef struct fcfs
{
    int process;    //Process Number
    int burst;      //Burst Time
    int arrival;    //Arrival Time
    int tat;        //Turn Around Time
    int wt;         //Waiting Time
}fcfs;

int sort(fcfs [], int);

int main()
{
    int n, i, temp = 0, AvTat = 0, AvWt = 0;

    printf ("Enter the number of processes: ");
    scanf ("%d", &n);
    fcfs arr[n];    //Array of type fcfs
    int tct[n];

    for (i = 0; i < n; i++)
    {
        arr[i].process = i;
        printf ("Enter the process %d data\n", arr[i].process);
        printf ("Enter CPU Burst: ");
        scanf ("%d", &(arr[i].burst));
        printf ("Enter the arrival time: ");
        scanf ("%d", &(arr[i].arrival));
    }
    
    //Sorting the processes according to their arrival time
    sort(arr, n);

    printf ("Process\t\tBurst Time\tArrival Time\tTurn Around Time\tWaiting Time\n");
    for (i = 0; i < n; i++)
    {
        tct[i] = temp + arr[i].burst;
        temp = tct[i];
        arr[i].tat = tct[i] - arr[i].arrival;
        arr[i].wt = arr[i].tat - arr[i].burst;
        AvTat = AvTat + arr[i].tat;
        AvWt = AvWt + arr[i].wt;
        printf ("%5d\t%15d\t\t%9d\t%12d\t%12d\n", arr[i].process, arr[i].burst, arr[i].arrival, arr[i].tat, arr[i].wt);
    }

    printf ("Average Turn Around Time: %d\nAverage Waiting Time: %d\n", AvTat / n, AvWt / n);
    
    return 0;
}

//Bubble Sort
int sort(fcfs arr[], int n)
{
    int i, j;
    fcfs k;

    for (i = 0; i < n - 1; i++)
    {
        for (j = i + 1; j < n; j++)
        {
            //Sorting the processes according to their arrival time
            if (arr[i].arrival > arr[j].arrival)
            {
                k = arr[i];
                arr[i] = arr[j];
                arr[j] = k;
            }
        }
    }
    return 0;
}



###### SJF ##########

#include <stdio.h>

typedef struct sjf
{
    int process;
    int burst;
    int arrival;
    int tat;
    int wt;
}sjf;

void sort(sjf [], int);

int main()
{
    int n, i, j, TCT, count_process = 0, count = 0, minBurst, pos;
    float AvTAT = 0.0, AvWT = 0.0;

    printf ("Enter the number of processes: ");
    scanf ("%d", &n);
    sjf arr[n];

    printf ("Enter the data of processes\n");
    for (i = 0; i < n; i++)
    {
        arr[i].process = i + 1;
        printf("Enter the burst time of process %d:", arr[i].process);
        scanf ("%d", &(arr[i].burst));
        printf ("Enter the arrival time of process %d:", arr[i].process);
        scanf ("%d", &(arr[i].arrival));
    }

    sort (arr, n);
    printf ("PROCESS\tARRIVAL TIME\tBURST TIME\n");
    for (i = 0; i < n; i++)
        printf ("%3d\t%5d\t\t%5d\n", arr[i].process, arr[i].arrival, arr[i].burst);

    TCT = arr[0].tat = arr[0].burst;
    arr[0].wt = arr[0].tat - arr[0].burst;
    arr[0].arrival = -1;
    sort(arr, n);
    count_process = 1;

    while (count_process < n)
    {
        minBurst = 999;
        count = 0;
        i = count_process;

        while (TCT >= arr[i].arrival && i < n)
        {
            count++;
            i++;
        }

        for (j = i - count; count != 0 && j < n; j++, count--)
        {
            if (arr[j].burst < minBurst)
            {
                minBurst = arr[j].burst;
                pos = j;
            }
        }
        TCT = TCT + arr[pos].burst;
        arr[pos].tat = TCT - arr[pos].arrival;
        arr[pos].wt = arr[pos].tat - arr[pos].burst;
        arr[pos].arrival = -1;
        sort (arr, n);
        count_process++;
    }
    printf ("Process\tTAT\tWT\n");
    for (i = 0; i < n; i++)
        printf ("%2d\t%2d\t%2d\n", arr[i].process, arr[i].tat, arr[i].wt);
    
    for (i = 0; i < n; i++)
    {
        AvTAT = AvTAT + arr[i].tat;
        AvWT = AvWT + arr[i].wt;
    }
    printf ("Average TAT: %.2f\nAverage WT: %.2f\n", AvTAT / n, AvWT / n);
    return 0;
}

void sort(sjf arr[], int n)
{
    int i, j;
    sjf temp;

    for (i = 0; i < n - 1; i++)
        for (j = i + 1; j < n; j++)
            if (arr[i].arrival > arr[j].arrival)
            {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
}


######### RR #########

#include <stdio.h>

typedef struct RR
{
    int process;        // Process number
    int burst;          // Burst time
    int arrival;        // Arrival time
    int remaining;      // Remaining time
    int complete;       // Completion time
    int tat;            // Turn around time
    int wt;             // Waiting Time
} RR;

int sort(RR [], int);

int main()
{
    int i, j, k, n, TCT = 0, Time_Quantum, update = 1, x = 0, rear = 0;
    float AvTAT = 0, AvWT = 0;

    printf("Enter the number of processes: ");
    scanf("%d", &n);
    printf("Enter the time quantum for the processes: ");
    scanf("%d", &Time_Quantum);
    RR arr[n];          // Array of type struct RR
    int ReadyQue[n];    // Ready Queue

    for (i = 0; i < n; i++)
    {
        arr[i].process = i + 1;
        printf("Enter the data for process %d\n", arr[i].process);
        printf("Burst Time: ");
        scanf("%d", &arr[i].burst);
        printf("Arrival: ");
        scanf("%d", &arr[i].arrival);
        arr[i].remaining = arr[i].burst;        // Initially the remaining time is the burst time
        arr[i].complete = 0;                    // Completion time is 0
    }

    // Sort the processes according to the arrival time
    sort(arr, n);
    printf("PROCESS\t\tARRIVAL\tBURST\n");
    for (i = 0; i < n; i++)
        printf("P%d\t\t%d\t%d\n", arr[i].process, arr[i].arrival, arr[i].burst);

    rear = 0;
    ReadyQue[rear] = 0;         // Process 0 is in ready queue

    while (update != 0)
    {
        for(j = 0; j < n; j++)
        {
            if(TCT >= arr[j].arrival)
            {
                x = 0;
                for(k = 0; k <= rear; k++)
                    if(ReadyQue[k] == j)
                        x++;
                
                // Insert the process in the ready queue if it isn't there
                if(x == 0)
                {
                    rear++;
                    ReadyQue[rear] = j;
                }
            }
        }
        if(rear == 0)
            i = 0;
        if(arr[i].remaining == 0)
            i++;
        if(i > rear)
            i = (i - 1) % rear;         // Wrap i, so that it is within the range of rear
        if(i <= rear)
        {
            if(arr[i].remaining > 0)
            {
                // If the remaining time of the current process is less than the given time quantum
                // then the process will complete
                if(arr[i].remaining < Time_Quantum)
                {
                    TCT = TCT + arr[i].remaining;
                    arr[i].remaining = 0;
                }
                // Else calculate the resulting remaining time and total completion time
                else
                {
                    TCT = TCT + Time_Quantum;
                    arr[i].remaining = arr[i].remaining - Time_Quantum;
                }
                arr[i].complete = TCT;          // Set the completion time of that process
            }
            i++;
        }
        update = 0;
        
        // Check if all the processes are done
        for(j = 0; j < n; j++)
            if(arr[j].remaining > 0)
                update++;
    }

    // Calculate turn around time and waiting time
    for (i = 0; i < n; i++)
    {
        arr[i].tat = arr[i].complete - arr[i].arrival;
        arr[i].wt = arr[i].tat - arr[i].burst;
    }

    printf("PROCESS\t\tTAT\tWT\n");
    for (i = 0; i < n; i++)
    {
        printf("P%d\t\t%d\t%d\n", arr[i].process, arr[i].tat, arr[i].wt);
        AvTAT = arr[i].tat + AvTAT;
        AvWT = arr[i].wt + AvWT;
    }

    printf("Average TAT: %.2f\nAverage WT: %.2f\n", AvTAT / n, AvWT / n);
    
    return 0;
}

int sort(RR arr[], int n)
{
    int i, j;
    RR temp;

    for (i = 0; i < n - 1; i++)
        for (j = i + 1; j < n; j++)
            if (arr[i].arrival > arr[j].arrival)
            {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }

    return 0;
}




Page Repacement

######## LRU #########

#include <stdio.h>

int findLRU(int time[], int n) {
    int i, minimum = time[0], pos = 0;

    for (i = 1; i < n; i++) {
        if (time[i] < minimum) {
            minimum = time[i];
            pos = i;
        }
    }
    return pos;
}

int main() {
    int no_of_frames, no_of_pages, frames[10], pages[30], counter = 0, time[10], flag1, flag2, i, j, pos, faults = 0;

    printf("Enter number of frames: ");
    scanf("%d", &no_of_frames);

    printf("Enter number of pages: ");
    scanf("%d", &no_of_pages);

    printf("Enter reference string: ");
    for (i = 0; i < no_of_pages; ++i) {
        scanf("%d", &pages[i]);
    }

    // Initialize frames
    for (i = 0; i < no_of_frames; ++i) {
        frames[i] = -1;
    }

    for (i = 0; i < no_of_pages; ++i) {
        flag1 = flag2 = 0;

        // Check if page is already in frame
        for (j = 0; j < no_of_frames; ++j) {
            if (frames[j] == pages[i]) {
                counter++;
                time[j] = counter;  // Update time for LRU
                flag1 = flag2 = 1;
                break;
            }
        }

        // If page is not in frame
        if (flag1 == 0) {
            for (j = 0; j < no_of_frames; ++j) {
                if (frames[j] == -1) {
                    counter++;
                    faults++;
                    frames[j] = pages[i];
                    time[j] = counter;  // Store time for LRU
                    flag2 = 1;
                    break;
                }
            }
        }

        // Replace the least recently used page
        if (flag2 == 0) {
            pos = findLRU(time, no_of_frames);
            counter++;
            faults++;
            frames[pos] = pages[i];
            time[pos] = counter;
        }

        // Display the current state of frames
        printf("\nFrames: ");
        for (j = 0; j < no_of_frames; ++j) {
            if (frames[j] != -1)
                printf("%d ", frames[j]);
            else
                printf("- ");
        }
    }

    printf("\n\nTotal Page Faults = %d\n", faults);

    return 0;
}



#### FIFO ##########

#include <stdio.h>

int main() {
    int no_of_frames, no_of_pages, frames[10], pages[30], i, j, k, faults = 0, pos = 0;

    printf("Enter number of frames: ");
    scanf("%d", &no_of_frames);

    printf("Enter number of pages: ");
    scanf("%d", &no_of_pages);

    printf("Enter reference string: ");
    for (i = 0; i < no_of_pages; ++i) {
        scanf("%d", &pages[i]);
    }

    // Initialize frames
    for (i = 0; i < no_of_frames; ++i) {
        frames[i] = -1;
    }

    // FIFO Page Replacement
    for (i = 0; i < no_of_pages; ++i) {
        int flag = 0;

        // Check if page is already in frame
        for (j = 0; j < no_of_frames; ++j) {
            if (frames[j] == pages[i]) {
                flag = 1;  // Page found, no fault
                break;
            }
        }

        // If page is not in frame
        if (flag == 0) {
            frames[pos] = pages[i];  // Insert page at position `pos`
            pos = (pos + 1) % no_of_frames;  // Circularly increase `pos` for FIFO
            faults++;  // Increment page fault count
        }

        // Display the current state of frames
        printf("\nFrames: ");
        for (k = 0; k < no_of_frames; ++k) {
            if (frames[k] != -1)
                printf("%d ", frames[k]);
            else
                printf("- ");
        }
    }

    printf("\n\nTotal Page Faults = %d\n", faults);

    return 0;
}



Disk Scheduling Algorithm

######## FCFS #########

#include <stdio.h>
#include <math.h>

int size = 8;

void FCFS(int arr[],int head)
{
	int seek_count = 0;
	int cur_track, distance;

	for(int i=0;i<size;i++)
	{
		cur_track = arr[i];
	
		// calculate absolute distance
		distance = fabs(head - cur_track);
	
		// increase the total count
		seek_count += distance;
	
		// accessed track is now new head
		head = cur_track;
	}

	printf("Total number of seek operations: %d\n",seek_count);
	
	// Seek sequence would be the same
	// as request array sequence
	printf("Seek Sequence is\n");

	for (int i = 0; i < size; i++) {
		printf("%d\n",arr[i]);
	}
}

//Driver code
int main()
{
	// request array
	int arr[8] = { 176, 79, 34, 60, 92, 11, 41, 114 };
	int head = 50;
	
	FCFS(arr,head);

	return 0;
}


